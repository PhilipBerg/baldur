---
title: "Baldur UPS Tutorial"
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Baldur UPS Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# 1. Setup
Here we cover the tutorial of `UPS-DS`.
The `UPS-DS` has one more condition than the `yeast-DS` and has one more replicate in each condition (`yeast-DS` is shown in `vignette("baldur_yeast_tutorial")`).
```{r setup}
library(baldur)
# Packages for pre-processing
library(dplyr, warn.conflicts = FALSE)
library(tidyr)

# Setup the design matrix
ups_design <- model.matrix(~ 0 + factor(rep(1:3, each = 4)))
colnames(ups_design) <- paste0('fmol', c(25, 50, 100))

# Normalize and add M-V trend
ups <- ups %>% 
  # Remove rows with NA for the sake of the tutorial
  drop_na() %>% 
  # Normalize the data
  psrn('identifier') %>% 
  calculate_mean_sd_trends(ups_design)

# For the contrast, we want to compare all conditions against each other.
# This can easily be achieved with the following:
ups_contrast <- combn(1:3, 2) %>% 
  t()
```
Lets go over the design and contrast matrix.
First, lets not how the design matrix uses subsets of the real columns of each condition:
```{r design}
colnames(ups[-1])
colnames(ups_design)
```
This lets `baldur` easily identify what columns that are of interest and setting up pre-cursors for the sampling.
In addition, `baldur` gets information on the number of conditions there are in the data (i.e., `ncol(ups_design)`) and the number of replicates in each condition (i.e., `colSums(ups_design)`).
Next, the contrast matrix:
```{r contrast}
ups_contrast
```
First, note how the contrast only has two columns; currently `baldur` only allows pair-wise comparisons.
Lets go over the rows, the first row tells us that the first column of the design matrix should be compared against the second.
I.e., the first row means `fmol25 - fmol50`.
The second row shows that the first column should be compared against the third, i.e., `fmol25 - fmol100`.
Finally, the last row shows that the second column should be compared against the third (`fmol50 - fmol100`).

# 2. Trend-partitioning and uncertainty estimation
First, I would like to note that reader that the remainder of the tutorial will look very similar to `vignette("baldur_yeast_tutorial")`.
The next step in `baldur` is to partition the trends in the mean and variance, and then to estimate the uncertainty of each measurement.

The trends before and after partitioning can then be visualized with `plot_gamma_regression`:
```{r plot_gam, fig.width=7.2, fig.height = 5}
plot_gamma(ups)
```
and the two individual plots can be plotted with `plot_gamma` and `plot_gamma_partition`.
We can then estimate the uncertainty for the partitioned data as follows:
```{r unc}
# Fit the gamma regression
gam_sin <- fit_gamma_regression(ups)
# Get each data points uncertainty
unc_sin <- estimate_uncertainty(ups, 'identifier', ups_design, gam_sin)
```

# 3. Sampling the posterior with parallel computation
Finally we sample the posterior of each row in the data.
`baludr` is very easy to run in parallel and this will drastically reduce the running time.
The only thing that needs to be changed is the `clusters` flag:
```{r parellel}
# Single trend
sin_results <- ups %>% 
  # Add hyper-priors for sigma
  estimate_gamma_priors(gam_sin) %>% 
  # For time purposes we only sample for 10 rows
  head(10) %>% 
  sample_posterior(
    'identifier',
    ups_design,
    ups_contrast,
    unc_sin,
    clusters = 2 # Change this to 1 to run sequentially
  )
```
Here `err` is the probability of error, i.e., the two tail-density supporting the null-hypothesis, `lfc` is the estimated log$_2$-fold change, `sigma` is the common variance, and `lp` is the log-posterior.
Columns without suffix shows the mean estimate from the posterior, while the suffixes `_025`, `_50`, and `_975`, are the 2.5, 50.0, and 97.5, percentiles, respectively.
The suffixes `_eff` and `_rhat` are the diagnostic variables returned by `rstan` (please see the Stan manual for details).
In general, a larger `_eff` indicates a better sampling efficiency, and `_rhat` compares the mixing within chains against between the chains and should be smaller than 1.05.
An important difference from `yeast-DS` is that each peptide gets three rows, one for each comparison in the contrast matrix.

# 4. Visualization of the results
`baldur` have two ways of visualizing the results 1) plotting sigma vs LFC and 2) Volcano plots.
To plot sigma against LFC we use `plot_sa`:
```{r plotting_sa, fig.show='hold', fig.width=7.2, fig.height = 7.2}
sin_results %>% 
  plot_sa(
    alpha = .05, # Level of significance
    lfc = 1      # Add LFC lines
  )
```

While it is hard to see with this few examples, in general a good decision is indicated by a lack of a trend between $\sigma$ and LFC.
To make a volcano plot one uses `plot_volcano` in a similar fashion to `plot_sa`:
```{r plotting_volc, fig.show='hold', fig.width=7.2, fig.height = 7.2}
sin_results %>% 
  plot_volcano(
    alpha = .05 # Level of significance
  )
```
